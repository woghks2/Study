# **\[파이썬\] 백준 18436 : 수열과 쿼리 37 (골드1)**

* [백준 18436 : 수열과 쿼리 37](https://www.acmicpc.net/problem/18436)

---

## **풀이**

### **방향성 생각**

* 세그트리

* 홀짝 튜플로 저장해도 되지만, 트리 뎁스를 바탕으로 하나만 구하면 나머지 하나는 바로 구할 수 있다.

---

### **전체코드**

```python
import sys
input = lambda : sys.stdin.readline().strip()

N = int(input())
arr = list(map(int,input().split()))
tree = [0]*(4*N)

def merge(left,right):
    return (left[0]+right[0], left[1]+right[1])

def build(x,s,e):
    if s==e:
        is_odd = arr[s]%2
        tree[x] = (is_odd,is_odd^1)
        return tree[x]
    m = (s+e)//2
    left = build(2*x+1,s,m)
    right = build(2*x+2,m+1,e)
    tree[x] = merge(left,right)
    return tree[x]


def update(x,s,e,idx,val):
    if s==e:
        arr[idx] = val
        is_odd = val%2
        tree[x] = (is_odd,is_odd^1)
        return tree[x]
    m = (s+e)//2
    if idx<=m:
        left = update(2*x+1,s,m,idx,val)
        right = tree[2*x+2]
    else:
        left = tree[2*x+1]
        right = update(2*x+2,m+1,e,idx,val)
    tree[x] = merge(left,right)
    return tree[x]

def query(x,s,e,l,r):
    if l<=s and e<=r:
        return tree[x]
    if e<l or s>r:
        return (0,0)
    m = (s+e)//2
    left = query(2*x+1,s,m,l,r)
    right = query(2*x+2,m+1,e,l,r)
    result = merge(left,right)
    return result

build(0,0,N-1)

for _ in range(int(input())):
    a,b,c = map(int,input().split())
    if a==1:
        update(0,0,N-1,b-1,c)
    else:
        print(query(0,0,N-1,b-1,c-1)[(a%2)^1])
```

### **코멘트**

* 각 세그트리의 노드에 저장하는 값들을 최대한 줄이기
