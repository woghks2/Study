# **\[파이썬\] 백준 12837 : 가계부(Hard) (골드1)**

* [백준 12837 : 가계부(Hard)](https://www.acmicpc.net/problem/12837)

---

## **풀이**

### **방향성 생각**

* 구간 합을 구하는 문제로 펜윅, 세그트리 둘 다 가능하다

---

### **전체코드 1: 펜윅**

```python
import sys
input = lambda : sys.stdin.readline().strip()

N,M = map(int,input().split())

fenwick = [0]*(N+1)

def update(x,diff):
    i = x
    while i<=N:
        fenwick[i] += diff
        i += i&(-i)

def cumsum(x):
    result = 0
    i = x
    while i:
        result += fenwick[i]
        i -= i&(-i)
    return result

for _ in range(M):
    a,b,c = map(int,input().split())
    if a==1:
        update(b,c)
    elif a==2:
        print(cumsum(c) - cumsum(b-1))
```
### **전체코드 2: 세그트리**

```python
import sys
input = lambda : sys.stdin.readline().strip()
DEFAULT = 0

N,M = map(int,input().split())

arr = [0]*N
segtree = [0]*(4*N)

def update(x,s,e,idx,val):
    if s==e:
        arr[idx] += val
        segtree[x] = arr[idx]
        return segtree[x]
    m = (s+e)//2
    if idx<=m:
        lv = update(2*x+1,s,m,idx,val)
        rv = segtree[2*x+2]
    else:
        lv = segtree[2*x+1]
        rv = update(2*x+2,m+1,e,idx,val)
    segtree[x] = lv+rv
    return segtree[x]
    
def query(x,s,e,l,r):
    if r<s or l>e:
        return 0
    if l<=s and e<=r:
        return segtree[x]
    m = (s+e)//2
    lv = query(2*x+1,s,m,l,r)
    rv = query(2*x+2,m+1,e,l,r)
    return lv+rv

for _ in range(M):
    a,b,c = map(int,input().split())
    if a==1:
        update(0,0,N-1,b-1,c)
    elif a==2:
        print(query(0,0,N-1,b-1,c-1))
```


### **코멘트**

* 하다 보니까 빌드가 필요없는 그런 문제들이 있다.

* 입력을 순차적으로 받아서 트리를 업데이트 하는 경우.