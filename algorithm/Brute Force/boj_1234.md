# **\[파이썬\] 백준 1234 : 크리스마스 트리 (골드2)**
* https://www.acmicpc.net/problem/1234
<br>


---

### **풀이**

#### **방향성 생각**
* 가지치기로 효과적으로 처리 가능
* 같은 층에는 색깔을 균형있게 놓아야 한다.
* 현재 가지고 있는 구슬을 사용하는 경우는 한정적이다.
* 약수를 구해서 케이스에 맞는 경우만 진행한다.
* 다음 단계에서 구슬 개수가 음수가 되면 불가능한 경우이므로 가지치기.
* DFS로 풀이

<br>

### **전체코드**
```python
n,red,green,blue = list(map(int,input().split()))

answer = 0
def dfs(h,r,g,b,cnt):
    
    global answer 
    
    # 남은 개수가 음수인 경우는 불가능한 경우. 구슬 장식을 오버해서 쓴 경우
    if r<0 or g<0 or b<0:
        return 

    # 1층까지 마무리 했으면 현재 개수 더해주기
    if h == 0:
        answer += cnt

    # 10 0 0 1 -> 10개를 red, 0개를 blue, 0개를 green, 같은 것이 있는 순열 개수
    if h == 10:
        for x,y,z,w in [(10,0,0,1),(0,10,0,1),(0,0,10,1),
                      (5,5,0,252),(5,0,5,252),(0,5,5,252)]:
            dfs(h-1,r-x,g-y,b-z,cnt*w)
        
    elif h == 9:
        for x,y,z,w in [(9,0,0,1),(0,9,0,1),(0,0,9,1),(3,3,3,1680)]:
            dfs(h-1,r-x,g-y,b-z,cnt*w)
    
    elif h == 8:
        for x,y,z,w in [(8,0,0,1),(0,8,0,1),(0,0,8,1),
                        (4,4,0,70),(4,0,4,70),(0,4,4,70)]:
            dfs(h-1,r-x,g-y,b-z,cnt*w)
        
    elif h == 7:
        for x,y,z,w in [(7,0,0,1),(0,7,0,1),(0,0,7,1)]:
            dfs(h-1,r-x,g-y,b-z,cnt*w)
        
    elif h == 6:
        for x,y,z,w in [(6,0,0,1),(0,6,0,1),(0,0,6,1),
                        (3,3,0,20),(3,0,3,20),(0,3,3,20),(2,2,2,90)]:
            dfs(h-1,r-x,g-y,b-z,cnt*w)

    elif h == 5:
        for x,y,z,w in [(5,0,0,1),(0,5,0,1),(0,0,5,1)]:
            dfs(h-1,r-x,g-y,b-z,cnt*w)

    elif h == 4:
        for x,y,z,w in [(4,0,0,1),(0,4,0,1),(0,0,4,1),
                        (2,2,0,6),(2,0,2,6),(0,2,2,6)]:
            dfs(h-1,r-x,g-y,b-z,cnt*w)
        
    elif h == 3:
        for x,y,z,w in [(3,0,0,1),(0,3,0,1),(0,0,3,1),(1,1,1,6)]:
            dfs(h-1,r-x,g-y,b-z,cnt*w)
        
    elif h == 2:
        for x,y,z,w in [(2,0,0,1),(0,2,0,1),(0,0,2,1),
                        (1,1,0,2),(1,0,1,2),(0,1,1,2)]:
            dfs(h-1,r-x,g-y,b-z,cnt*w)
        
    elif h == 1:
        for x,y,z,w in [(1,0,0,1),(0,1,0,1),(0,0,1,1)]:
            dfs(h-1,r-x,g-y,b-z,cnt*w)

dfs(n,red,green,blue,1)
print(answer)
```

#### **코멘트**

* DP 보다는 프루닝으로 효과적으로 처리할 수 있을거같아서 무식하게 하드코딩