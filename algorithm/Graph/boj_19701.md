# **\[파이썬\] 백준 19701 : 소 운전한다 (골드1)**

- https://www.acmicpc.net/problem/19701
  <br>

---

### **풀이**

#### **방향성 생각**

- 방문처리 배열 V에 돈까쓰를 먹은 유무를 추가해서 방문처리 관리하기

<br>

---

### **파이썬**

```python
import heapq as hq
import sys

input = lambda : sys.stdin.readline().strip()
INF = float('inf')

N,M = map(int,input().split())

# 간선 정보 받아주기
G = [[] for _ in range(N+1)]
for _ in range(M):
    a,b,cost,flavor = map(int,input().split())
    G[a].append((b,cost,flavor))
    G[b].append((a,cost,flavor))

# 방문처리 배열열
V = [[INF]*(N+1) for _ in range(2)]
V[0][1] = 0
heap = [(0,1,0)]
while heap:
    t,x,state = hq.heappop(heap)

    # 간선 수가 많아서 최적화필요
    if t > V[state][x]:
        continue

    # 인접 노드 탐색
    for nx,cost,flavor in G[x]:
        nt = t+cost

        # 돈까쓰를 먹지 않는 경우 state를 유지하고 다익스트라
        if nt < V[state][nx]:
            hq.heappush(heap,(nt,nx,state))
            V[state][nx] = nt

        # 돈까쓰를 먹을 수 있는 경우 (state == 0), state를 1로 바꿔주고 flavor만큼 감소소
        if not state and nt-flavor < V[1][nx]:
            hq.heappush(heap,(nt-flavor,nx,1))
            V[1][nx] = nt-flavor

for x in range(2,N+1):
    print(min(V[0][x],V[1][x]))
```

---

### **자바**

```java
import java.util.*;
import java.io.*;

public class Solution {

    static int N,M;
    static long INF=Long.MAX_VALUE;
    static ArrayList<ArrayList<int[]>> G;
    static long[][] V;
    static PriorityQueue<Node> heap;

    static class Node {
        long t;
        int x, state;

        Node(long t, int x, int state) {
            this.t = t;
            this.x = x;
            this.state = state;
        }
    }

    public static void main(String args[]) throws Exception {

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st;

        st = new StringTokenizer(br.readLine());
        N = Integer.parseInt(st.nextToken());
        M = Integer.parseInt(st.nextToken());

        // init Graph
        G = new ArrayList<ArrayList<int[]>>();
        for (int i=0; i<N+1; i++) {
            G.add(new ArrayList<>());
        }
        for (int i=0; i<M; i++) {
            st = new  StringTokenizer(br.readLine());
            int a = Integer.parseInt(st.nextToken());
            int b = Integer.parseInt(st.nextToken());
            int t = Integer.parseInt(st.nextToken());
            int flavor = Integer.parseInt(st.nextToken());
            G.get(a).add(new int[] {b,t,flavor});
            G.get(b).add(new int[] {a,t,flavor});
        }

        // init V array
        V = new long[2][N+1];
        Arrays.fill(V[0],INF);
        Arrays.fill(V[1],INF);
        V[0][1] = 0;

        // init heap
        heap = new PriorityQueue<Node>(
            (cur,next) -> Long.compare(cur.t,next.t));
        heap.offer(new Node(0,1,0)); // t,x,state
        while (!heap.isEmpty()) {
            Node cur = heap.poll();
            long t = cur.t;
            int x = cur.x, state = cur.state;

            if (t > V[state][x]) {
                continue;
            }

            for (int[] next : G.get(x)) {
                int nx = next[0];
                long nt = t + next[1];
                int flavor = next[2];

                if (nt < V[state][nx]) {
                    heap.offer(new Node(nt,nx,state));
                    V[state][nx] = nt;
                }

                if (state == 0 && nt-flavor < V[1][nx]) {
                    heap.offer(new Node(nt-flavor,nx,1));
                    V[1][nx] = nt-flavor;
                }
            }
        }

        for (int i=2; i<N+1; i++) {
            System.out.println(Math.min(V[0][i],V[1][i]));
        }
    }
}
```

- 자바 풀 때 유의점
  - 다익스트라/이분탐색/누적합 사용 시 Long 타입 생각하기.
  - 자료형 맞지 않는 경우 클래스 하나 만들어서 풀기.
  - 객체 생성할 때 new 붙이기.

#### **코멘트**

- 돈까쓰 먹는 경우에 elif로 적어서 탐색이 안됐는데, 조건 분기문 체크 하기.
