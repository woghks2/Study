# **\[파이썬\] 백준 1562 : 계단 수 (골드1)**
* https://www.acmicpc.net/problem/1562
<br>

---

## 문제
45656이란 수를 보자.

이 수는 인접한 모든 자리의 차이가 1이다. 이런 수를 계단 수라고 한다.

N이 주어질 때, 길이가 N이면서 0부터 9까지 숫자가 모두 등장하는 계단 수가 총 몇 개 있는지 구하는 프로그램을 작성하시오. 0으로 시작하는 수는 계단수가 아니다.
### 입력
첫째 줄에 N이 주어진다. N은 1보다 크거나 같고, 100보다 작거나 같은 자연수이다.

### 출력
첫째 줄에 정답을 1,000,000,000으로 나눈 나머지를 출력한다.

<br>


---

### **풀이**

#### **방향성 생각**
* 전형적인 bit DP
* 나눌 수 있는 상태가 10가지이다. bit로 분리하면 2**10
* 1024 * 숫자 10개 * 100자리 = 10만이므로 메모리도 충분하다.
* 다른 접근 방법으로는 0과 9를 선택하면 1~8은 자동으로 선택한 경우이므로, 0과 9를 기준으로 생각한다.
* 0, 9 등장유무를 나누면 4가지 상태로 나눌 수 있어서 메모리, 시간적으로 이득이다.
<br>


### **bit DP코드**
```python
N = int(input())
K = 10**9

# dp[자리수가 나타난 상태][i번째 자리수][j를 선택]
dp = [[[0]*10 for _ in range(N+1)] for _ in range(2**10)]

# 각 자리수가 나타난 bit ON
for i in range(1,10):
    dp[1<<i][1][i] = 1

for s in range(2**10):
    for i in range(1,N):
        for j in range(10):
            # 1~9는 0~8에서 한 칸 증가
            if j != 0: dp[s|(1<<j)][i+1][j] += dp[s][i][j-1]%K
            # 0~8은 1~9에서 한 칸 증가
            if j != 9: dp[s|(1<<j)][i+1][j] += dp[s][i][j+1]%K
            # 한 loop에서 증감이 다 일어나야해서 elif가 아님!

print(sum(dp[-1][-1])%K)
```

### **state DP코드**
```python
N = int(input())
K = 10**9

# dp[둘다선택x,0선택,9선택,둘다선택]
dp = [[[0]*10 for _ in range(N+1)] for _ in range(4)]
dp[0][1] = [0]+[1]*8+[0]
dp[2][1] = [0]*9+[1]

for s in range(4):
    for i in range(1,N):
        for j in range(10):
            
            # 1~8은 자유롭게 인접 숫자로 이동
            if 1<=j<=8:
                dp[s][i+1][j] += (dp[s][i][j-1]+dp[s][i][j+1])%K             
                
            # 0을 선택한 경우
            elif j==0:
                if s==0: dp[1][i+1][0] += dp[0][i][1]%K # x상태에서 0상태로
                elif s==2: dp[3][i+1][0] += dp[2][i][1]%K # 9상태에서 09상태로
                else : dp[s][i+1][0] += dp[s][i][1]%K # 나머지
                
            # 9를 선택한 경우
            else:
                if s==0: dp[2][i+1][9] += dp[0][i][8]%K # x상태에서 9상태로
                elif s==1: dp[3][i+1][9] += dp[1][i][8]%K # 0상태에서 09상태로
                else : dp[s][i+1][9] += dp[s][i][8]%K # 나머지

print(sum(dp[3][-1])%K)
```
#### **코멘트**

* state DP라고 말은 했지만, DP 자체가 다 state 구분이다.
* state를 나누는 관점을 바꿔서 생각하기.